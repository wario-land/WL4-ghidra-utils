#Auto-generate the patch file which can be used in WL4Editor
#@author shinespeciall
#@category Examples->Python
#@keybinding 
#@menupath 
#@toolbar 

# changelog: 
# v0.1: auto generate the comments and the #define lines for functions and global variables used in the TARGET_FUNC.
#       Then save the result as a C file on the Desktop path.
#       it seems the Ghidra cannot parse multiple line comments...

# the import here is like shit, but i don't want to find out useless lines manually
from ghidra.app.decompiler import DecompileOptions
from ghidra.app.decompiler import DecompInterface
from ghidra.util.task import ConsoleTaskMonitor
from ghidra.program.model import listing
from ghidra.program.model.symbol import SymbolUtilities
import os

def desktop_path():
    return os.path.join(os.path.expanduser('~'),"Desktop")

# change these before using the script
TARGET_FUNC = "Sub_8038A04_K0_TURN12_zako_bouba"
SaveFileFolder = desktop_path() + "\\"
funcs = getGlobalFunctions(TARGET_FUNC)

# Parse symbols address from the target function
TARGET_FUNC_ENTRY_ADDR_VALUE = 0
C_Code_string = ""
label_list = []
function_list = []

functionManager = currentProgram.getFunctionManager()
ifc = DecompInterface()
ifc.openProgram(currentProgram)
for func in funcs:
    if func.getName() == TARGET_FUNC:
        C_Code_string = ifc.decompileFunction(func, 0, ConsoleTaskMonitor()).getDecompiledFunction().getC()
        TARGET_FUNC_ENTRY_ADDR_VALUE = (func.getEntryPoint().getOffset() & 0x7FFFFFF)
        func_body = func.getBody()
        listing = currentProgram.getListing()
        opiter = listing.getInstructions(func_body, True)
        while opiter.hasNext():
            op = opiter.next()
            raw_pcode = op.toString()

            if (raw_pcode[0:3] == "ldr"):
                tmp_addr_str = raw_pcode[raw_pcode.find("[") + 1 : raw_pcode.find("]")]
                if (tmp_addr_str[0:1] == "r"):
                    continue;
                value = int(tmp_addr_str, 16)
                if value not in label_list:
                    label_list.append(value)

            if (raw_pcode[0:3] == "bl "):
                tmp_addr_str = raw_pcode[3:]
                value = int(tmp_addr_str, 16)
                if value not in function_list:
                    function_list.append(value)
        break

# parse symbols from symbol addresses
symbol_define_str_list = []
function_define_str_list = []

# helper function to get a Ghidra Address type
def getAddress(offset):
    return currentProgram.getAddressFactory().getDefaultAddressSpace().getAddress(offset)

# Functions
monitor = ConsoleTaskMonitor()
for fun_addr_num in function_list:
    try:
        func_instance = functionManager.getFunctionAt(getAddress(fun_addr_num))
        funcName = func_instance.getName()
    except AttributeError:
        print("cannot parse function address: {}".format(hex(fun_addr_num)))
        pass
    f_prototype_str = func_instance.getSignature().getPrototypeString()
    f_param_str = f_prototype_str[f_prototype_str.find("(") : f_prototype_str.find(")") + 1]
    f_return_type_str = f_prototype_str[0 : f_prototype_str.find(" ")]
    f_define_str = "#define " + funcName + " ((" + f_return_type_str + " (*)" + f_param_str + ") " + hex(fun_addr_num | 1) + ")"
    function_define_str_list.append(f_define_str)

# Global Symbols
# assumse all the ram symbols look like: "addr" + " " + addreess_str
# assumse all the rom symbols look like: "ddw" + " " + addreess_str + "h"
parsed_symbol_name_str = []
for i in range(len(label_list)):
    label_addr_num = label_list[i]
    data_instance = getDataAt(toAddr(label_addr_num))
    data_str = data_instance.toString()
    if (data_str[-1] == "h"):
        data_str = data_str[0: data_str.find("h")]
    data_addr_str = data_str[data_str.find(" ") + 1 : ]
    data_addr_num = int("0x" + data_addr_str, 16)
    data_addr_str = hex(data_addr_num)
    sym_instance = getSymbolAt(toAddr(data_addr_num))
    sym_name = ""
    type_str = "int"
    if sym_instance is not None:
        sym_name = sym_instance.getName()

        # try to infer type by size
        if getSymbolAt(toAddr(data_addr_num + 1)) is not None:
            type_str = "char"
        elif getSymbolAt(toAddr(data_addr_num + 2)) is not None:
            type_str = "short"
    else:
        sym_name = "Data_" + data_addr_str[data_str.find("x") + 1 : ]
    if (sym_name in parsed_symbol_name_str):
        continue
    s_define_str = "#define " + sym_name + " (*( volatile unsigned " + type_str + "*) " + data_addr_str + ")"
    symbol_define_str_list.append(s_define_str)
    parsed_symbol_name_str.append(sym_name)

# Export Logic
final_str = ""
final_str += "// @Description a function wrapper patch for " + TARGET_FUNC + " generated by Ghidra script: WL4FuncExporter.py\n"
modified_function_entry_addr_str = hex(TARGET_FUNC_ENTRY_ADDR_VALUE)
modified_function_entry_addr_str = modified_function_entry_addr_str[0 : modified_function_entry_addr_str.find("L")]
final_str += "// function starts at: " + modified_function_entry_addr_str + "\n\n"
final_str += "// @HookAddress [HookAddr]\n\n"

final_str += "/** starts from [HookAddr], no alignment byte needed\n"
final_str += " *  ends at [JumpBackAddr] with a branch instruction to jump out\n"
final_str += " * .thumb\n"
final_str += "    ldr r0, .DATA\n"
final_str += "    mov lr, r0\n"
final_str += "    ldr r0, .DATA + 4\n"
final_str += "    bx r0\n"
final_str += " * .DATA:\n"
final_str += "    .word 0x0801B929\n"
final_str += "    .word 0xAAAAAAAA\n"
final_str += " *\n"
final_str += " * Hook String generated by gcc: 01488646 01480047 29b90108 aaaaaaaa\n"
final_str += " */\n"
final_str += "// @HookString [fill this manually]\n\n"

for entry in symbol_define_str_list:
    final_str += entry + "\n"
final_str += "\n"
for entry in function_define_str_list:
    final_str += entry + "\n"

final_str += "\n\n"
final_str += "// [Copy the C Code from IDA pro for now.]\n"
# final_str += C_Code_string
final_str += "\n"

# write file
fo = open(SaveFileFolder + TARGET_FUNC + ".c", "w")
fo.write(final_str)
fo.close()
